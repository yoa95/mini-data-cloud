package com.minicloud.controlplane.execution;

import org.apache.arrow.memory.BufferAllocator;
import org.apache.arrow.vector.VectorSchemaRoot;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

/**
 * Main Arrow query execution engine that orchestrates vectorized operators.
 * Provides a pipeline for executing SQL queries using Arrow columnar processing.
 */
@Component
public class ArrowQueryExecutionEngine {
    
    @Autowired
    private ArrowMemoryManager memoryManager;
    
    /**
     * Executes a query plan using Arrow vectorized operators.
     */
    public QueryExecutionResult executeQuery(QueryExecutionPlan plan) {
        String queryId = plan.getQueryId();
        BufferAllocator queryAllocator = memoryManager.createQueryAllocator(queryId);
        
        try {
            long startTime = System.currentTimeMillis();
            
            // Execute the operator pipeline
            VectorSchemaRoot currentData = null;
            List<VectorizedOperator.OperatorStats> operatorStats = new ArrayList<>();
            
            for (VectorizedOperator operator : plan.getOperators()) {
                try (operator) {
                    BufferAllocator operatorAllocator = memoryManager.createOperatorAllocator(
                        queryAllocator, operator.getOperatorName());
                    
                    VectorSchemaRoot result = operator.execute(currentData, operatorAllocator);
                    
                    // Close previous data if it exists
                    if (currentData != null) {
                        currentData.close();
                    }
                    
                    currentData = result;
                    operatorStats.add(operator.getStats());
                }
            }
            
            long executionTime = System.currentTimeMillis() - startTime;
            
            return new QueryExecutionResult(
                queryId,
                currentData,
                operatorStats,
                executionTime,
                true,
                null
            );
            
        } catch (Exception e) {
            return new QueryExecutionResult(
                queryId,
                null,
                new ArrayList<>(),
                0,
                false,
                e.getMessage()
            );
        } finally {
            // Note: Don't close queryAllocator here as the result data still needs it
            // The caller is responsible for closing the result and its allocator
        }
    }
    
    /**
     * Creates a simple query execution plan for demonstration.
     * In a real implementation, this would be generated by the query planner.
     */
    public QueryExecutionPlan createSamplePlan(String queryId, String tableName, 
                                               List<String> columns, 
                                               FilterOperator.FilterPredicate filter,
                                               List<String> groupByColumns,
                                               List<AggregationOperator.AggregateFunction> aggregates) {
        List<VectorizedOperator> operators = new ArrayList<>();
        
        // 1. Scan operator to read data
        operators.add(new ScanOperator(tableName, columns, 1000)); // Sample 1000 rows
        
        // 2. Filter operator (if filter is provided)
        if (filter != null) {
            operators.add(new FilterOperator(filter));
        }
        
        // 3. Project operator (if not all columns are needed)
        List<String> projectedColumns = new ArrayList<>(columns);
        if (groupByColumns != null && !groupByColumns.isEmpty()) {
            // For aggregation, we need group-by columns plus aggregate columns
            projectedColumns.clear();
            projectedColumns.addAll(groupByColumns);
            for (AggregationOperator.AggregateFunction aggFunc : aggregates) {
                if (!projectedColumns.contains(aggFunc.getColumnName())) {
                    projectedColumns.add(aggFunc.getColumnName());
                }
            }
        }
        operators.add(new ProjectOperator(projectedColumns));
        
        // 4. Aggregation operator (if group-by is specified)
        if (groupByColumns != null && !groupByColumns.isEmpty()) {
            operators.add(new AggregationOperator(groupByColumns, aggregates));
        }
        
        return new QueryExecutionPlan(queryId, operators);
    }
    
    /**
     * Represents a query execution plan with a sequence of operators.
     */
    public static class QueryExecutionPlan {
        private final String queryId;
        private final List<VectorizedOperator> operators;
        
        public QueryExecutionPlan(String queryId, List<VectorizedOperator> operators) {
            this.queryId = queryId;
            this.operators = operators;
        }
        
        public String getQueryId() { return queryId; }
        public List<VectorizedOperator> getOperators() { return operators; }
    }
    
    /**
     * Represents the result of query execution.
     */
    public static class QueryExecutionResult implements AutoCloseable {
        private final String queryId;
        private final VectorSchemaRoot resultData;
        private final List<VectorizedOperator.OperatorStats> operatorStats;
        private final long executionTimeMs;
        private final boolean success;
        private final String errorMessage;
        
        public QueryExecutionResult(String queryId, VectorSchemaRoot resultData, 
                                  List<VectorizedOperator.OperatorStats> operatorStats,
                                  long executionTimeMs, boolean success, String errorMessage) {
            this.queryId = queryId;
            this.resultData = resultData;
            this.operatorStats = operatorStats;
            this.executionTimeMs = executionTimeMs;
            this.success = success;
            this.errorMessage = errorMessage;
        }
        
        public String getQueryId() { return queryId; }
        public VectorSchemaRoot getResultData() { return resultData; }
        public List<VectorizedOperator.OperatorStats> getOperatorStats() { return operatorStats; }
        public long getExecutionTimeMs() { return executionTimeMs; }
        public boolean isSuccess() { return success; }
        public String getErrorMessage() { return errorMessage; }
        
        @Override
        public void close() {
            if (resultData != null) {
                resultData.close();
            }
        }
    }
}